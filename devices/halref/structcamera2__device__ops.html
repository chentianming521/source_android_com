<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Android Hardware Abstraction Layer: camera2_device_ops Struct Reference</title>
<link href="http://source.android.com/devices/halref/tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="http://www.gstatic.com/external_hosted/source_android_com/sac_doxygen_jquery.js"></script>
<script type="text/javascript" src="http://source.android.com/devices/halref/dynsections.js"></script>
<link href="http://source.android.com/devices/halref/navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="http://source.android.com/devices/halref/resize.js"></script>
<script type="text/javascript" src="http://source.android.com/devices/halref/navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="http://source.android.com/devices/halref/doxygen.css" rel="stylesheet" type="text/css" />
<link href="http://source.android.com/devices/halref/hal_doxygen.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45455297-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="header">
            <table width=80%>
              <tr>
                <td><a href="http://source.android.com/index.html"><img src="http://source.android.com/assets/images/sac_logo.png" width="123" height="25" alt="Android Developers" /></td>
                <td><a class=toptab href="http://source.android.com/source/index.html">Source</a></td>
                <td><a class=devices href="http://source.android.com/devices/index.html">Devices</a></td>
                <td><a class=toptab href="http://source.android.com/security/index.html">Security</a></td>
                <td><a class=toptab href="http://source.android.com/compatibility/index.html">Compatibility</a></td>
                <td width=20%></td>
              </tr>
            </table>
  </div>
<hr class=light>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structcamera2__device__ops.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="structcamera2__device__ops.html#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">camera2_device_ops Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="camera2_8h_source.html">camera2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ab012a71e3b9226bc5f4a88333a174523"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#ab012a71e3b9226bc5f4a88333a174523">set_request_queue_src_ops</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, const <a class="el" href="camera2_8h.html#a54d643d8d946a5470f55d27e5a243b90">camera2_request_queue_src_ops_t</a> *request_src_ops)</td></tr>
<tr class="separator:ab012a71e3b9226bc5f4a88333a174523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebdd3315933af7a8bf9a0dd2b35fa0b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a1ebdd3315933af7a8bf9a0dd2b35fa0b">notify_request_queue_not_empty</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *)</td></tr>
<tr class="separator:a1ebdd3315933af7a8bf9a0dd2b35fa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d690a1370d6d69f44c29a443bf4a88"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a05d690a1370d6d69f44c29a443bf4a88">set_frame_queue_dst_ops</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, const <a class="el" href="camera2_8h.html#ae4b53e7009c0a62dc0a114d5e5be7c7a">camera2_frame_queue_dst_ops_t</a> *frame_dst_ops)</td></tr>
<tr class="separator:a05d690a1370d6d69f44c29a443bf4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7326081a0f6337d2ea0350e97df29943"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a7326081a0f6337d2ea0350e97df29943">get_in_progress_count</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *)</td></tr>
<tr class="separator:a7326081a0f6337d2ea0350e97df29943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45190127c83c2043f157114ca0471d0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#ac45190127c83c2043f157114ca0471d0">flush_captures_in_progress</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *)</td></tr>
<tr class="separator:ac45190127c83c2043f157114ca0471d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f563d631319e784c84bcc20f8c3b5a0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a0f563d631319e784c84bcc20f8c3b5a0">construct_default_request</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, int request_template, <a class="el" href="camera__common_8h.html#a650c3d4440786f728ec509ceb6e7a56c">camera_metadata_t</a> **request)</td></tr>
<tr class="separator:a0f563d631319e784c84bcc20f8c3b5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3f80477fffd85f9b9460982d174f57"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a8a3f80477fffd85f9b9460982d174f57">allocate_stream</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t width, uint32_t height, int format, const <a class="el" href="camera2_8h.html#a536cc194f0c1d12b496ba215a8b1129c">camera2_stream_ops_t</a> *stream_ops, uint32_t *stream_id, uint32_t *format_actual, uint32_t *usage, uint32_t *max_buffers)</td></tr>
<tr class="separator:a8a3f80477fffd85f9b9460982d174f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8ed6ea820509c814d2e6dadb87f075"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a1f8ed6ea820509c814d2e6dadb87f075">register_stream_buffers</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t stream_id, int num_buffers, buffer_handle_t *buffers)</td></tr>
<tr class="separator:a1f8ed6ea820509c814d2e6dadb87f075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0272748165f4fce65f7cbed68fc06066"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a0272748165f4fce65f7cbed68fc06066">release_stream</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t stream_id)</td></tr>
<tr class="separator:a0272748165f4fce65f7cbed68fc06066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af021bbb10dbb02f3a823fa4dfc154296"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#af021bbb10dbb02f3a823fa4dfc154296">allocate_reprocess_stream</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t width, uint32_t height, uint32_t format, const <a class="el" href="camera2_8h.html#a4167e086eaf5b1800208e0cd1a6e70dd">camera2_stream_in_ops_t</a> *reprocess_stream_ops, uint32_t *stream_id, uint32_t *consumer_usage, uint32_t *max_buffers)</td></tr>
<tr class="separator:af021bbb10dbb02f3a823fa4dfc154296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949f1281ed523bba4a1e14f65f6bdd0b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a949f1281ed523bba4a1e14f65f6bdd0b">allocate_reprocess_stream_from_stream</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t output_stream_id, const <a class="el" href="camera2_8h.html#a4167e086eaf5b1800208e0cd1a6e70dd">camera2_stream_in_ops_t</a> *reprocess_stream_ops, uint32_t *stream_id)</td></tr>
<tr class="separator:a949f1281ed523bba4a1e14f65f6bdd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc307b476ca4b6f5be00c5f31233d720"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#acc307b476ca4b6f5be00c5f31233d720">release_reprocess_stream</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t stream_id)</td></tr>
<tr class="separator:acc307b476ca4b6f5be00c5f31233d720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd866ca7988be9e54c8f6f19b98bbcb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a4fd866ca7988be9e54c8f6f19b98bbcb">trigger_action</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t trigger_id, int32_t ext1, int32_t ext2)</td></tr>
<tr class="separator:a4fd866ca7988be9e54c8f6f19b98bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777021c01b2f50565658538d16e1c241"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a777021c01b2f50565658538d16e1c241">set_notify_callback</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, <a class="el" href="camera2_8h.html#a692027d5ba583aa9e1cee75e98a0be11">camera2_notify_callback</a> notify_cb, void *user)</td></tr>
<tr class="separator:a777021c01b2f50565658538d16e1c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7b8461829bb94a6ce079f4632be4a5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a5f7b8461829bb94a6ce079f4632be4a5">get_metadata_vendor_tag_ops</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, vendor_tag_query_ops_t **ops)</td></tr>
<tr class="separator:a5f7b8461829bb94a6ce079f4632be4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab6038b81ef625ba0f2faf90ffd9c38"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a0ab6038b81ef625ba0f2faf90ffd9c38">dump</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, int fd)</td></tr>
<tr class="separator:a0ab6038b81ef625ba0f2faf90ffd9c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d8d8df3db481bf8eac02ca6dc28bbf"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcamera2__device__ops.html#a55d8d8df3db481bf8eac02ca6dc28bbf">get_instance_metadata</a> )(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, camera_metadata **instance_metadata)</td></tr>
<tr class="separator:a55d8d8df3db481bf8eac02ca6dc28bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="camera2_8h_source.html#l00527">527</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="af021bbb10dbb02f3a823fa4dfc154296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* allocate_reprocess_stream)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t width, uint32_t height, uint32_t format, const <a class="el" href="camera2_8h.html#a4167e086eaf5b1800208e0cd1a6e70dd">camera2_stream_in_ops_t</a> *reprocess_stream_ops,uint32_t *stream_id, uint32_t *consumer_usage, uint32_t *max_buffers)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allocate_reprocess_stream:</p>
<p>Allocate a new input stream for use, defined by the output buffer width, height, and the pixel format. Returns the new stream's ID, gralloc usage flags, and required simultaneously acquirable buffer count, on success. Error conditions:</p>
<ul>
<li>Requesting a width/height/format combination not listed as supported by the sensor's static characteristics</li>
<li>Asking for too many reprocessing streams to be configured at once.</li>
</ul>
<p>Input parameters:</p>
<ul>
<li>width, height, format: Specification for the buffers to be sent through this stream. Format must be a value from the HAL_PIXEL_FORMAT_* list.</li>
<li>reprocess_stream_ops: A structure of function pointers for acquiring and releasing buffers for this stream. The underlying stream will be configured based on the usage and max_buffers outputs.</li>
</ul>
<p>Output parameters:</p>
<ul>
<li>stream_id: An unsigned integer identifying this stream. This value is used in incoming requests to identify the stream, and in releasing the stream. These ids are numbered separately from the input stream ids.</li>
<li>consumer_usage: The gralloc usage mask needed by the HAL device for consuming the requested type of data. This is used in allocating new gralloc buffers for the stream buffer queue.</li>
<li>max_buffers: The maximum number of buffers the HAL device may need to have acquired at the same time. The device may not have more buffers acquired at the same time than this value. </li>
</ul>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00708">708</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a949f1281ed523bba4a1e14f65f6bdd0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* allocate_reprocess_stream_from_stream)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t output_stream_id, const <a class="el" href="camera2_8h.html#a4167e086eaf5b1800208e0cd1a6e70dd">camera2_stream_in_ops_t</a> *reprocess_stream_ops,uint32_t *stream_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allocate_reprocess_stream_from_stream:</p>
<p>Allocate a new input stream for use, which will use the buffers allocated for an existing output stream. That is, after the HAL enqueues a buffer onto the output stream, it may see that same buffer handed to it from this input reprocessing stream. After the HAL releases the buffer back to the reprocessing stream, it will be returned to the output queue for reuse.</p>
<p>Error conditions:</p>
<ul>
<li>Using an output stream of unsuitable size/format for the basis of the reprocessing stream.</li>
<li>Attempting to allocatee too many reprocessing streams at once.</li>
</ul>
<p>Input parameters:</p>
<ul>
<li>output_stream_id: The ID of an existing output stream which has a size and format suitable for reprocessing.</li>
<li>reprocess_stream_ops: A structure of function pointers for acquiring and releasing buffers for this stream. The underlying stream will use the same graphics buffer handles as the output stream uses.</li>
</ul>
<p>Output parameters:</p>
<ul>
<li>stream_id: An unsigned integer identifying this stream. This value is used in incoming requests to identify the stream, and in releasing the stream. These ids are numbered separately from the input stream ids.</li>
</ul>
<p>The HAL client must always release the reprocessing stream before it releases the output stream it is based on. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00754">754</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a3f80477fffd85f9b9460982d174f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* allocate_stream)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *,uint32_t width, uint32_t height, int format, const <a class="el" href="camera2_8h.html#a536cc194f0c1d12b496ba215a8b1129c">camera2_stream_ops_t</a> *stream_ops,uint32_t *stream_id, uint32_t *format_actual,uint32_t *usage, uint32_t *max_buffers)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allocate_stream:</p>
<p>Allocate a new output stream for use, defined by the output buffer width, height, target, and possibly the pixel format. Returns the new stream's ID, gralloc usage flags, minimum queue buffer count, and possibly the pixel format, on success. Error conditions:</p>
<ul>
<li>Requesting a width/height/format combination not listed as supported by the sensor's static characteristics</li>
<li>Asking for too many streams of a given format type (2 bayer raw streams, for example).</li>
</ul>
<p>Input parameters:</p>
<ul>
<li>width, height, format: Specification for the buffers to be sent through this stream. Format is a value from the HAL_PIXEL_FORMAT_* list. If HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED is used, then the platform gralloc module will select a format based on the usage flags provided by the camera HAL and the consumer of the stream. The camera HAL should inspect the buffers handed to it in the register_stream_buffers call to obtain the implementation-specific format if necessary.</li>
<li>stream_ops: A structure of function pointers for obtaining and queuing up buffers for this stream. The underlying stream will be configured based on the usage and max_buffers outputs. The methods in this structure may not be called until after allocate_stream returns.</li>
</ul>
<p>Output parameters:</p>
<ul>
<li>stream_id: An unsigned integer identifying this stream. This value is used in incoming requests to identify the stream, and in releasing the stream.</li>
<li>usage: The gralloc usage mask needed by the HAL device for producing the requested type of data. This is used in allocating new gralloc buffers for the stream buffer queue.</li>
<li>max_buffers: The maximum number of buffers the HAL device may need to have dequeued at the same time. The device may not dequeue more buffers than this value at the same time. </li>
</ul>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00632">632</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0f563d631319e784c84bcc20f8c3b5a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* construct_default_request)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, int request_template, <a class="el" href="camera__common_8h.html#a650c3d4440786f728ec509ceb6e7a56c">camera_metadata_t</a> **request)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a filled-in default request for standard camera use cases.</p>
<p>The device must return a complete request that is configured to meet the requested use case, which must be one of the CAMERA2_TEMPLATE_* enums. All request control fields must be included, except for android.request.outputStreams.</p>
<p>The metadata buffer returned must be allocated with allocate_camera_metadata. The framework takes ownership of the buffer. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00580">580</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0ab6038b81ef625ba0f2faf90ffd9c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* dump)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, int fd)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump state of the camera hardware </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00801">801</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac45190127c83c2043f157114ca0471d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* flush_captures_in_progress)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush all in-progress captures. This includes all dequeued requests (regular or reprocessing) that have not yet placed any outputs into a stream or the frame queue. Partially completed captures must be completed normally. No new requests may be dequeued from the request queue until the flush completes. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00567">567</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7326081a0f6337d2ea0350e97df29943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* get_in_progress_count)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of camera requests being processed by the device at the moment (captures/reprocesses that have had their request dequeued, but have not yet been enqueued onto output pipeline(s) ). No streams may be released by the framework until the in-progress count is 0. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00558">558</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a55d8d8df3db481bf8eac02ca6dc28bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* get_instance_metadata)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, camera_metadata **instance_metadata)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get device-instance-specific metadata. This metadata must be constant for a single instance of the camera device, but may be different between open() calls. The returned camera_metadata pointer must be valid until the device close() method is called.</p>
<p>Version information:</p>
<p>CAMERA_DEVICE_API_VERSION_2_0:</p>
<p>Not available. Framework may not access this function pointer.</p>
<p>CAMERA_DEVICE_API_VERSION_2_1:</p>
<p>Valid. Can be called by the framework. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00820">820</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5f7b8461829bb94a6ce079f4632be4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* get_metadata_vendor_tag_ops)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, vendor_tag_query_ops_t **ops)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get methods to query for vendor extension metadata tag infomation. May set ops to NULL if no vendor extension tags are defined. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00795">795</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ebdd3315933af7a8bf9a0dd2b35fa0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* notify_request_queue_not_empty)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify device that the request queue is no longer empty. Must only be called when the first buffer is added a new queue, or after the source has returned NULL in response to a dequeue call. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00544">544</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f8ed6ea820509c814d2e6dadb87f075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* register_stream_buffers)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t stream_id, int num_buffers, buffer_handle_t *buffers)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register buffers for a given stream. This is called after a successful allocate_stream call, and before the first request referencing the stream is enqueued. This method is intended to allow the HAL device to map or otherwise prepare the buffers for later use. num_buffers is guaranteed to be at least max_buffers (from allocate_stream), but may be larger. The buffers will already be locked for use. At the end of the call, all the buffers must be ready to be returned to the queue. If the stream format was set to HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, the camera HAL should inspect the passed-in buffers here to determine any platform-private pixel format information. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00657">657</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="acc307b476ca4b6f5be00c5f31233d720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* release_reprocess_stream)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t stream_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a reprocessing stream. Returns an error if called when get_in_progress_count is non-zero, or if the stream id is not valid. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00765">765</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0272748165f4fce65f7cbed68fc06066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* release_stream)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t stream_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a stream. Returns an error if called when get_in_progress_count is non-zero, or if the stream id is invalid. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00667">667</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05d690a1370d6d69f44c29a443bf4a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* set_frame_queue_dst_ops)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, const <a class="el" href="camera2_8h.html#ae4b53e7009c0a62dc0a114d5e5be7c7a">camera2_frame_queue_dst_ops_t</a> *frame_dst_ops)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass in output frame queue interface methods </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00549">549</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a777021c01b2f50565658538d16e1c241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* set_notify_callback)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, <a class="el" href="camera2_8h.html#a692027d5ba583aa9e1cee75e98a0be11">camera2_notify_callback</a> notify_cb, void *user)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notification callback setup </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00787">787</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab012a71e3b9226bc5f4a88333a174523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* set_request_queue_src_ops)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, const <a class="el" href="camera2_8h.html#a54d643d8d946a5470f55d27e5a243b90">camera2_request_queue_src_ops_t</a> *request_src_ops)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass in input request queue interface methods. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00536">536</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd866ca7988be9e54c8f6f19b98bbcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* trigger_action)(const struct <a class="el" href="structcamera2__device.html">camera2_device</a> *, uint32_t trigger_id, int32_t ext1, int32_t ext2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger asynchronous activity. This is used for triggering special behaviors of the camera 3A routines when they are in use. See the documentation for CAMERA2_TRIGGER_* above for details of the trigger ids and their arguments. </p>

<p>Definition at line <a class="el" href="camera2_8h_source.html#l00779">779</a> of file <a class="el" href="camera2_8h_source.html">camera2.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>hardware/libhardware/include/hardware/<a class="el" href="camera2_8h_source.html">camera2.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structcamera2__device__ops.html">camera2_device_ops</a></li>
    <li class="footer">Generated on Mon Jun 20 2016 18:43:21 for Android Hardware Abstraction Layer by
    <a href="http://source.android.com/index.html">
    <img class="footer" src="http://source.android.com/images/Android_Robot_100.png" alt="Android"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
